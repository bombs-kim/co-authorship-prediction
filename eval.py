"""
Note:
  'classifier.pth' and 'log.txt' are saved under ./backup/.../ directory.
  The argument parser of this script is automatically generated by
  docopt package using this help message itself.

Usage:
  eval.py (--classifier <str>) (--embedding <str>) (--lstm | --deepset) [options]
  eval.py (-h | --help)

Options:
  --classifier <str>    Path for trained classifier.pth (required)
  --embedding <str>     Path for embedding.pth (required)
  --answer-path <str>   File name to save answer [default: ./data/answer_private.txt]
  --query-path <str>    File name to draw query [default: ./data/query_private.txt]
  --device <int>        Cuda device         [default: 0]

  --lstm                When set, use bidirectional LSTM aggregator
  --deepset             When set, use DeepSet aggregator
  --hidden <int>        Hidden size         [default: 256]
  --dropout <float>     Dropout rate        [default: 0.5]
  --enable-all-pools    (DeepSet only option) enable all poolings

  --threshold <float>   Threshold [default: 0.5]
  -h --help             Show this screen
"""

import os
import warnings

# parsing library for cmd options and arguments https://github.com/docopt/docopt
from docopt import docopt
import numpy as np
import torch
from torch.utils.data import DataLoader

from data import QueryTestset
from model import Classifier
from utils import load_embedding


def main():
    args = docopt(__doc__)
    device = torch.device(int(args['--device']))
    print(f"{device} will be used")
    threshold = float(args['--threshold'])
    answer_path = args['--answer-path']
    query_path = args['--query-path']
    hidden = int(args['--hidden'])
    dropout = float(args['--dropout'])
    enable_all_pools = args['--enable-all-pools']
    
    if os.path.exists(answer_path):
        warnings.warn('Answer file already exists. Please delete it before run the code. Otherwise, lines will be appended.')

    testset = QueryTestset(query_path)
    testloader = DataLoader(testset, batch_size=1, num_workers=1, shuffle=False)
    
    embedding_mode, embedding = load_embedding(args['--embedding'], None, device)
    classifier = Classifier(embedding, hidden, dropout, args['--deepset'], False,
                            enable_all_pools=enable_all_pools).to(device)
    classifier.load_state_dict(torch.load(args['--classifier']))
    classifier.eval()

    with torch.no_grad():
        for collab in testloader:
            score = classifier(collab.to(device))
            if score >= threshold:
                answer = True
            else:
                answer = False
            with open(answer_path, 'a') as f:
                f.write(str(answer)+'\n')

if __name__ == '__main__':
    main()
